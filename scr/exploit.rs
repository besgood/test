use std::process::Command;
use std::io::{self, Write};
use std::fs::OpenOptions;
use chrono::Local;
use log::{info, error};

/// Runs a list of AI-suggested exploit commands after user confirmation
pub fn run_payloads(payloads: &[String]) {
    for (i, cmd) in payloads.iter().enumerate() {
        println!("[{}] Suggested payload: {}", i + 1, cmd);
    }

    println!("\nSelect payloads to execute (comma-separated indices or 'all'): ");
    io::stdout().flush().unwrap();
    let mut selection = String::new();
    io::stdin().read_line(&mut selection).unwrap();
    let selection = selection.trim().to_lowercase();

    let indices: Vec<usize> = if selection == "all" {
        (0..payloads.len()).collect()
    } else {
        selection
            .split(',')
            .filter_map(|s| s.trim().parse::<usize>().ok().map(|n| n - 1))
            .collect()
    };

    for &index in &indices {
        if let Some(payload) = payloads.get(index) {
            println!("\n[Executing] {}", payload);
            let parts: Vec<&str> = payload.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }

            let output = Command::new(parts[0])
                .args(&parts[1..])
                .output();

            match output {
                Ok(out) => {
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    println!("[Output]\n{}", stdout);
                    info!("Payload '{}' executed successfully.", payload);
                    log_payload(payload, true, &stdout);
                }
                Err(e) => {
                    error!("Failed to execute '{}': {}", payload, e);
                    log_payload(payload, false, &e.to_string());
                }
            }
        }
    }
}

/// Parses an AI response into a list of payload commands
pub fn extract_payloads(ai_response: &str) -> Vec<String> {
    ai_response
        .lines()
        .filter(|line| line.trim().starts_with("$") || line.contains("curl") || line.contains("sqlmap"))
        .map(|line| line.trim_start_matches("$").trim().to_string())
        .collect()
}

/// Logs payload execution success or failure with output
fn log_payload(command: &str, success: bool, output: &str) {
    let timestamp = Local::now();
    let status = if success { "success" } else { "failure" };
    let entry = format!(
        "{{\"timestamp\":\"{}\",\"command\":\"{}\",\"status\":\"{}\",\"output\":\"{}\"}}\n",
        timestamp.format("%Y-%m-%dT%H:%M:%S"),
        command.replace('"', "'"),
        status,
        output.replace('"', "'"),
    );

    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open("payload_log.jsonl")
        .expect("Unable to open payload log file");
    file.write_all(entry.as_bytes()).unwrap();
}
